#!/usr/bin/env bash

CLASHTUI_CONFIG_DIR=${XDG_CONFIG_HOME:-$HOME/.config}/clashtui
CLASHTUI_INSTALL_DIR=/opt/clashtui
INSTALL_RES_URL_PREFIX=https://raw.githubusercontent.com/JohanChane/clashtui/refs/heads/main/InstallRes

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
  echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
  echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $1" >&2
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

create_mihomo_user() {
  if ! id "mihomo" &>/dev/null; then
    log_info "Creating mihomo user and group..."
    sudo groupadd --system mihomo
    sudo useradd --system --no-create-home --gid mihomo --shell /bin/false mihomo
  else
    log_info "mihomo user already exists"
  fi
}

create_mihomo_systemd_unit() {
  log_info "Creating mihomo systemd unit..."

  sudo tee "$CLASHTUI_INSTALL_DIR/clashtui_mihomo.service" >/dev/null <<'EOF'
[Unit]
Description=mihomo Daemon, Another Clash Kernel.
After=network.target NetworkManager.service systemd-networkd.service iwd.service

[Service]
Type=simple
User=mihomo
Group=mihomo
LimitNPROC=500
LimitNOFILE=1000000
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE
Restart=always
ExecStartPre=/usr/bin/sleep 1s
ExecStart=/opt/clashtui/mihomo -d /opt/clashtui/mihomo_config
ExecReload=/bin/kill -HUP $MAINPID

[Install]
WantedBy=multi-user.target
EOF

  sudo ln -s $CLASHTUI_INSTALL_DIR/clashtui_mihomo.service /etc/systemd/system/
  sudo systemctl daemon-reload
}

create_clashtui_config() {
  log_info "Creating clashtui config.yaml..."

  tee "$CLASHTUI_CONFIG_DIR/config.yaml" >/dev/null <<'EOF'
basic:
  clash_config_dir: '/opt/clashtui/mihomo_config'
  clash_bin_path: '/opt/clashtui/mihomo'
  clash_config_path: '/opt/clashtui/mihomo_config/config.yaml'
  timeout: null
service:
  clash_srv_name: 'clashtui_mihomo'
  is_user: false
extra:
  edit_cmd:
  open_dir_cmd:
EOF

  echo -n "Do you want to download basic_clash_config.yaml? (y/N): "
  read -r response
  if [ "$response" = "y" ] || [ "$response" = "Y" ]; then
    log_info "Downloading basic_clash_config.yaml..."
    curl -o $CLASHTUI_CONFIG_DIR/basic_clash_config.yaml $INSTALL_RES_URL_PREFIX/basic_clash_config.yaml
  else
    tee "$CLASHTUI_CONFIG_DIR/basic_clash_config.yaml" >/dev/null <<'EOF'
mixed-port: 7890
mode: rule
log-level: info
external-controller: 127.0.0.1:9090
EOF
  fi

  sudo cp "$CLASHTUI_CONFIG_DIR/basic_clash_config.yaml" "$CLASHTUI_INSTALL_DIR/mihomo_config/config.yaml"

  mkdir "$CLASHTUI_CONFIG_DIR/profiles"
  mkdir "$CLASHTUI_CONFIG_DIR/templates"
  tee "$CLASHTUI_CONFIG_DIR/templates/template_proxy_providers" >/dev/null <<'EOF'
# This is a comment
# Place each subscription on a separate line
EOF

  echo -n "Do you want to download templates? (y/N): "
  read -r response
  if [ "$response" = "y" ] || [ "$response" = "Y" ]; then
    log_info "Downloading templates..."
    curl -o $CLASHTUI_CONFIG_DIR/templates/common_tpl.yaml $INSTALL_RES_URL_PREFIX/templates/common_tpl.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl_with_all.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl_with_all.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl_with_filter.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl_with_filter.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl_with_rulest.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl_with_ruleset.yaml
  fi
}

detect_architecture() {
  local arch
  arch=$(uname -m)

  case "$arch" in
  x86_64 | amd64)
    echo "amd64"
    ;;
  aarch64 | arm64)
    echo "arm64"
    ;;
  armv7l | armhf)
    echo "armv7"
    ;;
  armv6l)
    echo "armv6"
    ;;
  i386 | i686)
    echo "386"
    ;;
  *)
    echo "unsupported"
    ;;
  esac
}

detect_os() {
  local os
  os=$(uname -s | tr '[:upper:]' '[:lower:]')

  case "$os" in
  linux)
    echo "linux"
    ;;
  darwin)
    echo "darwin"
    ;;
  freebsd)
    echo "freebsd"
    ;;
  *)
    echo "unsupported"
    ;;
  esac
}

# 使用/proc/cpuinfo检测CPU指令集等级（屏蔽v4，最高到v3）
detect_using_proc() {
    # 从/proc/cpuinfo获取CPU指令集(flags字段)
    local flags=$(grep -m 1 '^flags' /proc/cpuinfo | awk '{print $0}')
    
    # 检查是否为amd64(x86-64)架构（基础要求）
    if ! echo "$flags" | grep -q ' lm '; then
        echo ""  # 非amd64架构，输出空
        return
    fi

    # 定义各等级所需的指令集（最高到v3）
    # x86-64-v1基础指令集
    local v1_required="cmov cx8 fpu fxsr mmx osfxsr sce sse sse2"
    # x86-64-v2扩展指令集（基于v1）
    local v2_required="cx16 lahf_lm popcnt sse3 sse4_1 sse4_2 ssse3"
    # x86-64-v3高级指令集（基于v2）
    local v3_required="avx avx2 bmi1 bmi2 f16c fma lzcnt movbe osxsave"
    # x86-64-v4旗舰指令集（基于v3）
    local v4_required="avx512f avx512bw avx512cd avx512dq avx512vl"

    # 检查指令集是否全部满足
    local check_flags
    check_flags() {
        local required="$1"
        for flag in $required; do
            # 精确匹配指令集（前后有空格，避免部分匹配）
            if ! echo " $flags " | grep -q " $flag "; then
                return 1
            fi
        done
        return 0
    }

    # 从高等级开始判断（v3 -> v2 -> v1）
    # if check_flags "$v1_required" && check_flags "$v2_required" && check_flags "$v3_required" && check_flags "$v4_required"; then
    #     echo "v4"
    # el
    if check_flags "$v1_required" && check_flags "$v2_required" && check_flags "$v3_required"; then
        echo "v3"
    elif check_flags "$v1_required" && check_flags "$v2_required"; then
        echo "v2"
    elif check_flags "$v1_required"; then
        echo "v1"
    else
        echo ""  # 不满足v1基础要求，输出空
    fi
}

# 使用动态链接器检测CPU指令集等级（屏蔽v4，最高到v3）
detect_using_ld() {
    local ld_path="/lib64/ld-linux-x86-64.so.2"
    
    # 检查动态链接器是否存在且可执行（非amd64架构可能不存在）
    if [ ! -x "$ld_path" ]; then
        echo ""  # 非amd64架构，输出空
        return 0
    fi

    # 获取动态链接器帮助信息中带有"(supported, searched)"标记的等级
    local levels=$("$ld_path" --help 2>/dev/null | grep -oP 'x86-64-v\d+(?=.*\(supported, searched\))' | sort -u)
    
    # 如果没有找到支持的等级信息，返回空
    if [ -z "$levels" ]; then
        echo ""
        return 0
    fi

    # 查找最高支持的等级（最高到v3）
    local highest_level=""
    for level in $levels; do
        case $level in
            x86-64-v3) highest_level="v3"; break ;;  # 最高等级为v3
            x86-64-v2) highest_level="v2" ;;
            x86-64-v1) highest_level="v1" ;;
            x86-64-v4) highest_level="v3" ;;  # 屏蔽v4，视为v3
        esac
    done

    echo "$highest_level"
    return 0
}

# 主函数：处理输出格式
detect_cpu_level() {
    # 先尝试使用动态链接器方法
    local level=$(detect_using_ld)
    
    # 如果动态链接器方法返回空，使用proc方法
    if [ -z "$level" ]; then
        level=$(detect_using_proc)
    fi
    
    # 处理输出格式：为空则输出空，有值则加前缀-
    if [ -n "$level" ]; then
        echo "-$level"
    else
        echo ""
    fi
}


download_mihomo() {
  # 先获取基础架构值
  local base_arch=$(detect_architecture)
  # 当基础架构为amd64时，拼接cpu_level值；否则直接使用基础架构值
  local arch=$([ "$base_arch" = "amd64" ] && echo "${base_arch}$(detect_cpu_level)" || echo "$base_arch")
  local os=$(detect_os)
  local download_url
  local temp_dir=$(mktemp -d)
  local latest_version=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

  if [ "$arch" = "unsupported" ] || [ "$os" = "unsupported" ]; then
    log_error "Unsupported architecture ($(uname -m)) or OS ($(uname -s))"
    rm -rf "$temp_dir"
    return 1
  fi

  download_url="https://github.com/MetaCubeX/mihomo/releases/latest/download/mihomo-${os}-${arch}-${latest_version}.gz"

  log_info "Detected: OS=$os, Arch=$arch, LatestVersion=$latest_version, download_url=$download_url"

  curl -L "$download_url" -o "$temp_dir/mihomo.gz"
  gunzip -c "$temp_dir/mihomo.gz" >"$temp_dir/mihomo"

  local binary_path
  if [ -f "$temp_dir/mihomo" ]; then
    binary_path="$temp_dir/mihomo"
  else
    log_error "Could not find binary in the downloaded archive"
    rm -rf "$temp_dir"
    return 1
  fi

  sudo install -m 755 "$binary_path" "$CLASHTUI_INSTALL_DIR/mihomo"
  log_info "Successfully installed mihomo to: $CLASHTUI_INSTALL_DIR/mihomo"
  rm -rf "$temp_dir"
}

install_mihomo() {
  if command_exists mihomo; then
    sudo ln -s "$(which mihomo)" $CLASHTUI_INSTALL_DIR/mihomo
  elif command_exists clash-meta; then
    sudo ln -s "$(which clash-meta)" $CLASHTUI_INSTALL_DIR/mihomo
  else
    download_mihomo
  fi

  create_mihomo_user
  sudo gpasswd -a $USER mihomo

  sudo chown mihomo:mihomo "$CLASHTUI_INSTALL_DIR/mihomo_config"
  create_mihomo_systemd_unit
}

install_clashtui() {
  if ! command_exists clashtui; then
    download_clashtui
  fi

  create_clashtui_config
}

download_clashtui() {
  local arch=$(detect_architecture)
  local os=$(detect_os)
  local download_url
  local temp_dir=$(mktemp -d)
  local latest_version=$(curl -s "https://api.github.com/repos/JohanChane/clashtui/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

  if [ "$arch" = "unsupported" ] || [ "$os" = "unsupported" ]; then
    log_error "Unsupported architecture ($(uname -m)) or OS ($(uname -s))"
    rm -rf "$temp_dir"
    return 1
  fi

  download_url="https://github.com/JohanChane/clashtui/releases/latest/download/clashtui-${os}-${arch}-${latest_version}.gz"

  log_info "Detected: OS=$os, Arch=$arch, LatestVersion=$latest_version, download_url=$download_url"

  curl -L "$download_url" -o "$temp_dir/clashtui.gz"
  gunzip -c "$temp_dir/clashtui.gz" >"$temp_dir/clashtui"

  local binary_path
  if [ -f "$temp_dir/clashtui" ]; then
    binary_path="$temp_dir/clashtui"
  else
    log_error "Could not find binary in the downloaded archive"
    rm -rf "$temp_dir"
    return 1
  fi

  sudo install -m 755 "$binary_path" "$CLASHTUI_INSTALL_DIR/clashtui"
  sudo ln -s "$CLASHTUI_INSTALL_DIR/clashtui" /usr/local/bin/clashtui
  log_info "Successfully installed clashtui to: $CLASHTUI_INSTALL_DIR/clashtui"
  rm -rf "$temp_dir"
}

uninstall() {
  echo "Please make sure the mihomo daemon has been stopped before uninstallation."
  echo -n "Continue with uninstallation? (y/N): "
  read -r response
  if [ "$response" != "y" ] && [ "$response" != "Y" ]; then
    echo "Uninstallation cancelled."
    return 1
  fi

  sudo rm -f /etc/systemd/system/clashtui_mihomo.service
  sudo systemctl daemon-reload
  sudo rm -f /usr/local/bin/clashtui
  sudo rm -rf /opt/clashtui

  echo "[Optional] Delete the mihomo user and group"
  echo "  sudo gpasswd -d $USER mihomo"
  echo "  sudo userdel mihomo"
}

show_help() {
  echo "Usage: $0 [OPTION]"
  echo "Install or uninstall clashtui"
  echo
  echo "Options:"
  echo "  -h, --help       Show this help message and exit"
  echo "  -u, --uninstall  Uninstall clashtui"
  echo
  echo "If no options are provided, the script will install clashtui."
}

main() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    -u | --uninstall)
      uninstall
      return 0
      ;;
    -h | --help)
      show_help
      return 0
      ;;
    *)
      log_error "Unknown option"
      show_help
      return 1
      ;;
    esac
  done

  sudo mkdir -p "$CLASHTUI_INSTALL_DIR/mihomo_config"
  mkdir -p "$CLASHTUI_CONFIG_DIR"

  install_mihomo
  install_clashtui

  log_warn 'Please log out and log back in for the group file permissions to take effect'
}

main "$@"
